PROJECT STRUCTURE:
==================================================
ğŸ“ app/
    ğŸ“„ __init__.py
    ğŸ“„ main.py
    ğŸ“„ seed_all.py
    ğŸ“„ 1.py
    ğŸ“ core/
        ğŸ“„ database.py
        ğŸ“„ dependencies.py
        ğŸ“„ __init__.py
        ğŸ“„ security.py
        ğŸ“„ config.py
    ğŸ“ schemas/
        ğŸ“„ menu.py
        ğŸ“„ __init__.py
        ğŸ“„ user.py
        ğŸ“„ table.py
        ğŸ“„ order.py
        ğŸ“„ restaurant.py
        ğŸ“„ ingredient.py
    ğŸ“ routers/
        ğŸ“„ menu.py
        ğŸ“„ export.py
        ğŸ“„ auth.py
        ğŸ“„ __init__.py
        ğŸ“„ admin.py
        ğŸ“„ table.py
        ğŸ“„ order.py
        ğŸ“„ restaurant.py
        ğŸ“„ ingredient.py
    ğŸ“ models/
        ğŸ“„ menu.py
        ğŸ“„ __init__.py
        ğŸ“„ user.py
        ğŸ“„ order.py
        ğŸ“„ restaurant.py
        ğŸ“„ ingredient.py
    ğŸ“ services/
        ğŸ“„ export_service.py
        ğŸ“„ backup_service.py
==================================================


################################################################################
FILE: __init__.py
################################################################################




################################################################################
FILE: main.py
################################################################################

from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from routers import auth, restaurant, table, menu, ingredient, order, export, admin

app = FastAPI(title="Restaurant Network API")

app.include_router(auth.router)
app.include_router(restaurant.router)
app.include_router(table.router)
app.include_router(menu.router)
app.include_router(ingredient.router)
app.include_router(order.router)
app.include_router(export.router)
app.include_router(admin.router)

app.mount("/static", StaticFiles(directory="../static"), name="static")

@app.get("/")
async def read_index():
    return FileResponse("../static/index.html")


################################################################################
FILE: seed_all.py
################################################################################

import asyncio
import sys
from os.path import dirname, abspath

# Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿ÑƒÑ‚ÑŒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ñ‹ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»Ğ¸ Ğ±ĞµĞ· Ğ¿Ñ€Ğ¸ÑÑ‚Ğ°Ğ²ĞºĞ¸ app
sys.path.insert(0, dirname(abspath(__file__)))

from core.database import async_session
from core.security import get_password_hash
from models.user import Role, User
from models.restaurant import Restaurant, Table
from models.menu import Category, MenuItem
from models.ingredient import Ingredient, MenuItemIngredient
from sqlalchemy import select

async def seed():
    async with async_session() as session:
        print("ğŸš€ ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ğ½Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…...")

        # 1. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ€Ğ¾Ğ»ĞµĞ¹
        roles_data = [
            Role(id=1, name="customer", description="ĞšĞ»Ğ¸ĞµĞ½Ñ‚"),
            Role(id=2, name="staff", description="ĞÑ„Ğ¸Ñ†Ğ¸Ğ°Ğ½Ñ‚"),
            Role(id=3, name="manager", description="ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€"),
            Role(id=4, name="admin", description="ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€")
        ]
        for r in roles_data:
            await session.merge(r)
        await session.commit()
        print("âœ… Ğ Ğ¾Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹.")

        # 2. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ĞµĞ¹ (ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ = Ğ›Ğ¾Ğ³Ğ¸Ğ½)
        users_data = [
            ("admin", "admin@resto.ru", 4),
            ("manager", "manager@resto.ru", 3),
            ("staff", "staff@resto.ru", 2),
            ("user", "user@resto.ru", 1),
        ]
        for username, email, role_id in users_data:
            user_check = await session.execute(select(User).where(User.username == username))
            if not user_check.scalars().first():
                new_user = User(
                    username=username,
                    email=email,
                    hashed_password=get_password_hash(username), # ĞŸĞ°Ñ€Ğ¾Ğ»ÑŒ ĞºĞ°Ğº Ğ»Ğ¾Ğ³Ğ¸Ğ½
                    role_id=role_id
                )
                session.add(new_user)
        await session.commit()
        print("âœ… ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ñ‹ (Ğ¿Ğ°Ñ€Ğ¾Ğ»Ğ¸ ÑĞ¾Ğ²Ğ¿Ğ°Ğ´Ğ°ÑÑ‚ Ñ Ğ»Ğ¾Ğ³Ğ¸Ğ½Ğ°Ğ¼Ğ¸).")

        # 3. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½Ğ° Ğ¸ ÑÑ‚Ğ¾Ğ»Ğ¸ĞºĞ¾Ğ²
        rest = Restaurant(name="Gourmet Plaza", address="ÑƒĞ». ĞŸÑƒÑˆĞºĞ¸Ğ½Ğ°, 10", phone="+79991234567")
        session.add(rest)
        await session.flush()

        tables = [Table(number=i, capacity=4, restaurant_id=rest.id) for i in range(1, 6)]
        session.add_all(tables)
        print("âœ… Ğ ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½ Ğ¸ ÑÑ‚Ğ¾Ğ»Ğ¸ĞºĞ¸ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ñ‹.")

        # 4. ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ğ¸ ĞœĞµĞ½Ñ
        cat1 = Category(name="ĞŸĞ¸Ñ†Ñ†Ğ°")
        cat2 = Category(name="ĞĞ°Ğ¿Ğ¸Ñ‚ĞºĞ¸")
        session.add_all([cat1, cat2])
        await session.flush()

        items = [
            MenuItem(name="ĞœĞ°Ñ€Ğ³Ğ°Ñ€Ğ¸Ñ‚Ğ°", price=450.0, category_id=cat1.id, is_available=True),
            MenuItem(name="ĞŸĞµĞ¿Ğ¿ĞµÑ€Ğ¾Ğ½Ğ¸", price=550.0, category_id=cat1.id, is_available=True),
            MenuItem(name="ĞšĞ¾Ğ»Ğ° 0.5", price=120.0, category_id=cat2.id, is_available=True),
        ]
        session.add_all(items)
        print("âœ… ĞœĞµĞ½Ñ Ğ·Ğ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¾.")

        # 5. Ğ˜Ğ½Ğ³Ñ€ĞµĞ´Ğ¸ĞµĞ½Ñ‚Ñ‹
        ing1 = Ingredient(name="ĞœÑƒĞºĞ°", unit="ĞºĞ³", stock_quantity=50.0)
        ing2 = Ingredient(name="Ğ¡Ñ‹Ñ€ ĞœĞ¾Ñ†Ğ°Ñ€ĞµĞ»Ğ»Ğ°", unit="ĞºĞ³", stock_quantity=20.0)
        session.add_all([ing1, ing2])
        
        await session.commit()
        print("ğŸ ĞĞ°Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾ ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾!")

if __name__ == "__main__":
    asyncio.run(seed())


################################################################################
FILE: 1.py
################################################################################

import os
from pathlib import Path

# ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
OUTPUT_FILE = "full_project.txt"
EXCLUDE_DIRS = {
    '.git', '__pycache__', '.venv', 'venv', 'env', 
    '.idea', '.vscode', 'node_modules', 'dist', 'build'
}
EXCLUDE_FILES = {OUTPUT_FILE, '.DS_Store', 'package-lock.json'}
# Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğ¹, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ ÑÑ‚Ğ¾Ğ¸Ñ‚ Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ‚ÑŒ (Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ÑŒ)
ALLOWED_EXTENSIONS = {
    '.py', '.txt', '.md', '.json', '.yaml', '.yml', 
    '.html', '.css', '.js', '.sql', '.ini', '.cfg'
}

def get_project_structure(root_dir):
    """Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ ÑÑ‚Ñ€Ğ¾ĞºĞ¾Ğ²Ğ¾Ğµ Ğ¿Ñ€ĞµĞ´ÑÑ‚Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ´Ñ€ĞµĞ²Ğ¾Ğ²Ğ¸Ğ´Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ°."""
    structure = []
    for root, dirs, files in os.walk(root_dir):
        # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ Ğ¸ÑĞºĞ»ÑÑ‡Ğ°ĞµĞ¼Ñ‹Ğµ Ğ¿Ğ°Ğ¿ĞºĞ¸ Ğ¸Ğ· Ğ¾Ğ±Ñ…Ğ¾Ğ´Ğ°
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        
        level = root.replace(root_dir, '').count(os.sep)
        indent = ' ' * 4 * level
        folder_name = os.path.basename(root)
        if folder_name:
            structure.append(f"{indent}ğŸ“ {folder_name}/")
        
        sub_indent = ' ' * 4 * (level + 1)
        for f in files:
            if f not in EXCLUDE_FILES:
                structure.append(f"{sub_indent}ğŸ“„ {f}")
    return "\n".join(structure)

def main():
    root_dir = os.getcwd()
    output_path = Path(root_dir) / OUTPUT_FILE

    with open(output_path, 'w', encoding='utf-8') as outfile:
        # 1. Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ğ¸ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ
        outfile.write(f"PROJECT STRUCTURE:\n")
        outfile.write("=" * 50 + "\n")
        outfile.write(get_project_structure(root_dir))
        outfile.write("\n" + "=" * 50 + "\n\n")

        # 2. ĞĞ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¸ Ğ·Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ Ğ¸Ñ… ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ
        for root, dirs, files in os.walk(root_dir):
            dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
            
            for file in files:
                if file in EXCLUDE_FILES:
                    continue
                
                file_path = Path(root) / file
                relative_path = file_path.relative_to(root_dir)

                # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ
                if file_path.suffix.lower() in ALLOWED_EXTENSIONS:
                    outfile.write(f"\n{'#'*80}\n")
                    outfile.write(f"FILE: {relative_path}\n")
                    outfile.write(f"{'#'*80}\n\n")
                    
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='replace') as infile:
                            outfile.write(infile.read())
                    except Exception as e:
                        outfile.write(f"[ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ñ‡Ñ‚ĞµĞ½Ğ¸Ğ¸ Ñ„Ğ°Ğ¹Ğ»Ğ°: {e}]\n")
                    
                    outfile.write("\n\n")

    print(f"Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! Ğ’ĞµÑÑŒ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½ Ğ² Ñ„Ğ°Ğ¹Ğ»: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()



################################################################################
FILE: core/database.py
################################################################################

from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.orm import DeclarativeBase
from core.config import settings  # Ğ£Ğ±Ñ€Ğ°Ğ»Ğ¸ app.

engine = create_async_engine(settings.DATABASE_URL, future=True, echo=True)
async_session = async_sessionmaker(engine, expire_on_commit=False, class_=AsyncSession)

class Base(DeclarativeBase):
    pass

async def get_db():
    async with async_session() as session:
        yield session


################################################################################
FILE: core/dependencies.py
################################################################################

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from core.database import get_db
from core.config import settings
from models.user import User, Role

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="auth/login")

async def get_current_user(
    token: str = Depends(oauth2_scheme), 
    db: AsyncSession = Depends(get_db)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception

    result = await db.execute(
        select(User).where(User.username == username)
    )
    user = result.scalars().first()

    if user is None:
        raise credentials_exception
    return user

class RoleChecker:
    def __init__(self, allowed_roles: list[str]):
        self.allowed_roles = allowed_roles

    async def __call__(
        self, 
        current_user: User = Depends(get_current_user),
        db: AsyncSession = Depends(get_db)
    ):
        result = await db.execute(select(Role).where(Role.id == current_user.role_id))
        role = result.scalars().first()
        
        if role.name not in self.allowed_roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Ğ£ Ğ²Ğ°Ñ Ğ½ĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ¿Ñ€Ğ°Ğ² Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ"
            )
        return current_user


################################################################################
FILE: core/__init__.py
################################################################################




################################################################################
FILE: core/security.py
################################################################################

import bcrypt
from datetime import datetime, timedelta, timezone
from typing import Any, Union
from jose import jwt
from core.config import settings

def create_access_token(subject: Union[str, Any], expires_delta: timedelta = None) -> str:
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ JWT Ñ‚Ğ¾ĞºĞµĞ½Ğ°"""
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(
            minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
        )
    to_encode = {"exp": expire, "sub": str(subject)}
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° ÑĞ¾Ğ²Ğ¿Ğ°Ğ´ĞµĞ½Ğ¸Ñ Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ Ğ¸ Ñ…ĞµÑˆĞ°"""
    # bcrypt Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ Ğ±Ğ°Ğ¹Ñ‚Ğ°Ğ¼Ğ¸, Ğ¿Ğ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ¿ĞµÑ€ĞµĞ²Ğ¾Ğ´Ğ¸Ğ¼ ÑÑ‚Ñ€Ğ¾ĞºĞ¸ Ğ² utf-8
    password_bytes = plain_password.encode('utf-8')
    hashed_bytes = hashed_password.encode('utf-8')
    return bcrypt.checkpw(password_bytes, hashed_bytes)

def get_password_hash(password: str) -> str:
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ñ…ĞµÑˆĞ° Ğ¸Ğ· Ğ¿Ğ°Ñ€Ğ¾Ğ»Ñ"""
    # Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµĞ¼ "ÑĞ¾Ğ»ÑŒ" Ğ¸ Ñ…ĞµÑˆĞ¸Ñ€ÑƒĞµĞ¼
    password_bytes = password.encode('utf-8')
    salt = bcrypt.gensalt()
    hashed = bcrypt.hashpw(password_bytes, salt)
    return hashed.decode('utf-8') # Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ´Ğ»Ñ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ñ Ğ² Ğ‘Ğ”


################################################################################
FILE: core/config.py
################################################################################

import os
from pathlib import Path
from pydantic_settings import BaseSettings, SettingsConfigDict

# ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¿ÑƒÑ‚ÑŒ Ğº Ğ¿Ğ°Ğ¿ĞºĞµ, Ğ³Ğ´Ğµ Ğ»ĞµĞ¶Ğ¸Ñ‚ ÑÑ‚Ğ¾Ñ‚ Ñ„Ğ°Ğ¹Ğ» (app/core)
# .parent.parent.parent â€” ÑÑ‚Ğ¾ Ğ²Ñ‹Ñ…Ğ¾Ğ´ Ğ½Ğ° ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ ĞºĞ¾Ñ€Ğ½Ñ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° (course_work_restaurant)
BASE_DIR = Path(__file__).resolve().parent.parent.parent
ENV_FILE = os.path.join(BASE_DIR, ".env")

class Settings(BaseSettings):
    DATABASE_URL: str
    SECRET_KEY: str
    ALGORITHM: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    # Ğ¯Ğ²Ğ½Ğ¾ ÑƒĞºĞ°Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ°Ğ±ÑĞ¾Ğ»ÑÑ‚Ğ½Ñ‹Ğ¹ Ğ¿ÑƒÑ‚ÑŒ Ğº .env
    model_config = SettingsConfigDict(
        env_file=ENV_FILE, 
        env_file_encoding='utf-8',
        extra="ignore" # Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ»Ğ¸ÑˆĞ½Ğ¸Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ² .env
    )

try:
    settings = Settings()
except Exception as e:
    print(f"ĞĞ¨Ğ˜Ğ‘ĞšĞ: ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·Ğ¸Ñ‚ÑŒ Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒ Ñ„Ğ°Ğ¹Ğ» {ENV_FILE}")
    raise e


################################################################################
FILE: schemas/menu.py
################################################################################

from pydantic import BaseModel, ConfigDict
from typing import Optional, List

class CategoryBase(BaseModel):
    name: str

class CategoryCreate(CategoryBase):
    pass

class CategoryRead(CategoryBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

class MenuItemBase(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    is_available: bool = True
    category_id: int

class MenuItemCreate(MenuItemBase):
    pass

class MenuItemRead(MenuItemBase):
    id: int
    model_config = ConfigDict(from_attributes=True)


################################################################################
FILE: schemas/__init__.py
################################################################################




################################################################################
FILE: schemas/user.py
################################################################################

from pydantic import BaseModel, EmailStr, ConfigDict
from typing import Optional

class UserBase(BaseModel):
    username: str
    email: EmailStr

class UserCreate(UserBase):
    password: str
    role_id: int = 1

class UserRead(UserBase):
    id: int
    role_id: int
    is_active: bool

    model_config = ConfigDict(from_attributes=True)

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None


################################################################################
FILE: schemas/table.py
################################################################################

from pydantic import BaseModel, ConfigDict

class TableBase(BaseModel):
    number: int
    capacity: int
    restaurant_id: int

class TableCreate(TableBase):
    pass

class TableRead(TableBase):
    id: int

    model_config = ConfigDict(from_attributes=True)


################################################################################
FILE: schemas/order.py
################################################################################

from pydantic import BaseModel, ConfigDict
from datetime import datetime
from typing import List, Optional
from models.order import OrderStatus

class OrderItemBase(BaseModel):
    menu_item_id: int
    quantity: int

class OrderCreate(BaseModel):
    table_id: Optional[int] = None
    items: List[OrderItemBase]

class OrderItemRead(BaseModel):
    menu_item_id: int
    quantity: int
    price_at_order: float

    model_config = ConfigDict(from_attributes=True)

class OrderRead(BaseModel):
    id: int
    user_id: int
    table_id: Optional[int]
    status: OrderStatus
    created_at: datetime
    items: List[OrderItemRead]

    model_config = ConfigDict(from_attributes=True)

class OrderStatusUpdate(BaseModel):
    status: OrderStatus


################################################################################
FILE: schemas/restaurant.py
################################################################################

from pydantic import BaseModel, ConfigDict
from typing import Optional

class RestaurantBase(BaseModel):
    name: str
    address: str
    phone: Optional[str] = None

class RestaurantCreate(RestaurantBase):
    pass

class RestaurantRead(RestaurantBase):
    id: int

    model_config = ConfigDict(from_attributes=True)


################################################################################
FILE: schemas/ingredient.py
################################################################################

from pydantic import BaseModel, ConfigDict
from typing import Optional, List

class IngredientBase(BaseModel):
    name: str
    unit: str
    stock_quantity: float = 0.0

class IngredientCreate(IngredientBase):
    pass

class IngredientRead(IngredientBase):
    id: int
    model_config = ConfigDict(from_attributes=True)

class RecipeLinkCreate(BaseModel):
    menu_item_id: int
    ingredient_id: int
    amount: float

class RecipeRead(BaseModel):
    ingredient_id: int
    ingredient_name: str
    amount: float
    unit: str
    model_config = ConfigDict(from_attributes=True)


################################################################################
FILE: routers/menu.py
################################################################################

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List, Optional

from core.database import get_db
from core.dependencies import RoleChecker
from models.menu import Category, MenuItem
from schemas.menu import (
    CategoryCreate, CategoryRead, 
    MenuItemCreate, MenuItemRead
)

router = APIRouter(prefix="/menu", tags=["menu"])

is_staff = RoleChecker(["admin", "manager"])

@router.get("/categories", response_model=List[CategoryRead])
async def list_categories(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(Category))
    return result.scalars().all()

@router.post("/categories", response_model=CategoryRead)
async def create_category(
    cat_in: CategoryCreate, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    new_cat = Category(**cat_in.model_dump())
    db.add(new_cat)
    await db.commit()
    await db.refresh(new_cat)
    return new_cat

@router.get("/items", response_model=List[MenuItemRead])
async def list_items(
    category_id: Optional[int] = None, 
    db: AsyncSession = Depends(get_db)
):
    query = select(MenuItem)
    if category_id:
        query = query.where(MenuItem.category_id == category_id)
    
    result = await db.execute(query)
    return result.scalars().all()

@router.post("/items", response_model=MenuItemRead)
async def create_item(
    item_in: MenuItemCreate, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    cat_res = await db.execute(select(Category).where(Category.id == item_in.category_id))
    if not cat_res.scalars().first():
        raise HTTPException(status_code=404, detail="Category not found")
    
    new_item = MenuItem(**item_in.model_dump())
    db.add(new_item)
    await db.commit()
    await db.refresh(new_item)
    return new_item

@router.patch("/items/{item_id}", response_model=MenuItemRead)
async def update_item_availability(
    item_id: int, 
    is_available: bool,
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    result = await db.execute(select(MenuItem).where(MenuItem.id == item_id))
    item = result.scalars().first()
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    
    item.is_available = is_available
    await db.commit()
    await db.refresh(item)
    return item


################################################################################
FILE: routers/export.py
################################################################################

from fastapi import APIRouter, Depends, Query, HTTPException
from fastapi.responses import Response
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import Literal

from core.database import get_db
from core.dependencies import RoleChecker
from models.menu import MenuItem
from services import export_service

router = APIRouter(prefix="/export", tags=["export"])

is_staff = RoleChecker(["admin", "manager"])

@router.get("/menu")
async def export_menu(
    format: Literal["json", "csv"] = Query(..., description="Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ Ğ²Ñ‹Ğ³Ñ€ÑƒĞ·ĞºĞ¸"),
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    result = await db.execute(select(MenuItem))
    items = result.scalars().all()
    
    data = [
        {
            "id": i.id,
            "name": i.name,
            "price": i.price,
            "available": i.is_available,
            "category_id": i.category_id
        } for i in items
    ]

    if format == "json":
        content = export_service.to_json(data)
        media_type = "application/json"
        filename = "menu_export.json"
    else:
        content = export_service.to_csv(data)
        media_type = "text/csv"
        filename = "menu_export.csv"

    return Response(
        content=content,
        media_type=media_type,
        headers={
            "Content-Disposition": f"attachment; filename={filename}"
        }
    )


################################################################################
FILE: routers/auth.py
################################################################################

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from core.database import get_db
from core.security import verify_password, get_password_hash, create_access_token
from models.user import User
from schemas.user import UserCreate, UserRead, Token
from core.dependencies import get_current_user

router = APIRouter(prefix="/auth", tags=["auth"])

@router.post("/register", response_model=UserRead)
async def register(user_in: UserCreate, db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User).where(User.username == user_in.username))
    if result.scalars().first():
        raise HTTPException(status_code=400, detail="Username already registered")
    
    new_user = User(
        username=user_in.username,
        email=user_in.email,
        hashed_password=get_password_hash(user_in.password),
        role_id=user_in.role_id
    )
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    return new_user

@router.post("/login", response_model=Token)
async def login(form_data: OAuth2PasswordRequestForm = Depends(), db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User).where(User.username == form_data.username))
    user = result.scalars().first()
    
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(subject=user.username)
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserRead)
async def get_me(current_user: User = Depends(get_current_user)):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸ Ğ¾ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ğµ (Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸)"""
    return current_user


################################################################################
FILE: routers/__init__.py
################################################################################




################################################################################
FILE: routers/admin.py
################################################################################

from fastapi import APIRouter, Depends, HTTPException
from core.dependencies import RoleChecker
from services import backup_service

router = APIRouter(prefix="/admin", tags=["admin"])

is_admin = RoleChecker(["admin"])

@router.post("/backup")
async def trigger_backup(current_user = Depends(is_admin)):
    """Ğ—Ğ°Ğ¿ÑƒÑĞº ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ñ€ĞµĞ·ĞµÑ€Ğ²Ğ½Ğ¾Ğ¹ ĞºĞ¾Ğ¿Ğ¸Ğ¸ Ğ‘Ğ” (Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ â„–3)"""
    result = backup_service.create_db_backup()
    
    if result["status"] == "error":
        raise HTTPException(status_code=500, detail=result["message"])
    
    return result


################################################################################
FILE: routers/table.py
################################################################################

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List

from core.database import get_db
from core.dependencies import RoleChecker
from models.restaurant import Table, Restaurant
from schemas.table import TableCreate, TableRead

router = APIRouter(prefix="/tables", tags=["tables"])

is_staff = RoleChecker(["admin", "manager"])

@router.get("/", response_model=List[TableRead])
async def list_tables(restaurant_id: int = None, db: AsyncSession = Depends(get_db)):
    query = select(Table)
    if restaurant_id:
        query = query.where(Table.restaurant_id == restaurant_id)
    
    result = await db.execute(query)
    return result.scalars().all()

@router.post("/", response_model=TableRead, status_code=status.HTTP_201_CREATED)
async def create_table(
    table_in: TableCreate, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    res = await db.execute(select(Restaurant).where(Restaurant.id == table_in.restaurant_id))
    if not res.scalars().first():
        raise HTTPException(status_code=404, detail="Restaurant not found")
    
    new_table = Table(**table_in.model_dump())
    db.add(new_table)
    await db.commit()
    await db.refresh(new_table)
    return new_table

@router.delete("/{table_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_table(
    table_id: int, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    result = await db.execute(select(Table).where(Table.id == table_id))
    table = result.scalars().first()
    if not table:
        raise HTTPException(status_code=404, detail="Table not found")
    
    await db.delete(table)
    await db.commit()
    return None


################################################################################
FILE: routers/order.py
################################################################################

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from typing import List

from models.menu import MenuItem
from core.database import get_db
from core.dependencies import RoleChecker, get_current_user
from models.order import Order, OrderItem, OrderStatus
from schemas.order import OrderCreate, OrderRead, OrderStatusUpdate

router = APIRouter(prefix="/orders", tags=["orders"])

is_staff = RoleChecker(["admin", "manager", "staff"])

@router.post("/", response_model=OrderRead, status_code=status.HTTP_201_CREATED)
async def create_order(
    order_in: OrderCreate, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(get_current_user)
):
    new_order = Order(
        user_id=current_user.id,
        table_id=order_in.table_id
    )
    db.add(new_order)
    
    await db.flush()

    for item in order_in.items:
        res = await db.execute(select(MenuItem).where(MenuItem.id == item.menu_item_id))
        menu_item = res.scalars().first()
        
        if not menu_item:
            raise HTTPException(
                status_code=404, 
                detail=f"Ğ‘Ğ»ÑĞ´Ğ¾ Ñ ID {item.menu_item_id} Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾"
            )
        
        if not menu_item.is_available:
            raise HTTPException(
                status_code=400, 
                detail=f"Ğ‘Ğ»ÑĞ´Ğ¾ {menu_item.name} ÑĞµĞ¹Ñ‡Ğ°Ñ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾"
            )

        order_item = OrderItem(
            order_id=new_order.id,
            menu_item_id=menu_item.id,
            quantity=item.quantity,
            price_at_order=menu_item.price
        )
        db.add(order_item)

    await db.commit()
    
    result = await db.execute(
        select(Order)
        .options(selectinload(Order.items))
        .where(Order.id == new_order.id)
    )
    return result.scalars().first()

@router.get("/my", response_model=List[OrderRead])
async def get_my_orders(
    db: AsyncSession = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """Ğ˜ÑÑ‚Ğ¾Ñ€Ğ¸Ñ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ (ĞšĞ»Ğ¸ĞµĞ½Ñ‚Ğ°)"""
    result = await db.execute(
        select(Order)
        .options(selectinload(Order.items))
        .where(Order.user_id == current_user.id)
        .order_by(Order.created_at.desc())
    )
    return result.scalars().all()

@router.get("/all", response_model=List[OrderRead])
async def get_all_orders(
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ğ´Ğ»Ñ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»Ğ° (ĞĞ´Ğ¼Ğ¸Ğ½/ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€/ĞÑ„Ğ¸Ñ†Ğ¸Ğ°Ğ½Ñ‚)"""
    result = await db.execute(
        select(Order)
        .options(selectinload(Order.items))
        .order_by(Order.created_at.desc())
    )
    return result.scalars().all()

@router.patch("/{order_id}/status", response_model=OrderRead)
async def update_order_status(
    order_id: int,
    status_update: OrderStatusUpdate,
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    """Ğ˜Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ° (Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»Ğ°)"""
    result = await db.execute(
        select(Order)
        .options(selectinload(Order.items))
        .where(Order.id == order_id)
    )
    order = result.scalars().first()
    
    if not order:
        raise HTTPException(status_code=404, detail="Order not found")
    
    order.status = status_update.status
    await db.commit()
    await db.refresh(order)
    return order


################################################################################
FILE: routers/restaurant.py
################################################################################

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import List

from core.database import get_db
from core.dependencies import RoleChecker
from models.restaurant import Restaurant
from schemas.restaurant import RestaurantCreate, RestaurantRead

router = APIRouter(prefix="/restaurants", tags=["restaurants"])

# ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ñ€Ğ¾Ğ»ĞµĞ¹
is_admin = RoleChecker(["admin"])

@router.get("/", response_model=List[RestaurantRead])
async def list_restaurants(db: AsyncSession = Depends(get_db)):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½Ğ¾Ğ² (Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ Ğ²ÑĞµĞ¼)"""
    result = await db.execute(select(Restaurant))
    return result.scalars().all()

@router.post("/", response_model=RestaurantRead, status_code=status.HTTP_201_CREATED)
async def create_restaurant(
    rest_in: RestaurantCreate, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_admin) # Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ Ğ°Ğ´Ğ¼Ğ¸Ğ½
):
    """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ Ñ„Ğ¸Ğ»Ğ¸Ğ°Ğ» (Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞĞ´Ğ¼Ğ¸Ğ½)"""
    new_rest = Restaurant(**rest_in.model_dump())
    db.add(new_rest)
    await db.commit()
    await db.refresh(new_rest)
    return new_rest

@router.get("/{restaurant_id}", response_model=RestaurantRead)
async def get_restaurant(restaurant_id: int, db: AsyncSession = Depends(get_db)):
    """Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ¾ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ¼ Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½Ğµ"""
    result = await db.execute(select(Restaurant).where(Restaurant.id == restaurant_id))
    rest = result.scalars().first()
    if not rest:
        raise HTTPException(status_code=404, detail="Restaurant not found")
    return rest

@router.delete("/{restaurant_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_restaurant(
    restaurant_id: int, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_admin)
):
    """Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ñ„Ğ¸Ğ»Ğ¸Ğ°Ğ» (Ğ¢Ğ¾Ğ»ÑŒĞºĞ¾ ĞĞ´Ğ¼Ğ¸Ğ½)"""
    result = await db.execute(select(Restaurant).where(Restaurant.id == restaurant_id))
    rest = result.scalars().first()
    if not rest:
        raise HTTPException(status_code=404, detail="Restaurant not found")
    
    await db.delete(rest)
    await db.commit()
    return None


################################################################################
FILE: routers/ingredient.py
################################################################################

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from typing import List

from core.database import get_db
from core.dependencies import RoleChecker
from models.ingredient import Ingredient, MenuItemIngredient
from models.menu import MenuItem
from schemas.ingredient import (
    IngredientCreate, IngredientRead, 
    RecipeLinkCreate, RecipeRead
)

router = APIRouter(prefix="/ingredients", tags=["ingredients"])

is_staff = RoleChecker(["admin", "manager"])

@router.get("/", response_model=List[IngredientRead])
async def list_ingredients(db: AsyncSession = Depends(get_db)):
    """Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ²ÑĞµÑ… Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ‚Ğ¾Ğ² Ğ½Ğ° ÑĞºĞ»Ğ°Ğ´Ğµ"""
    result = await db.execute(select(Ingredient))
    return result.scalars().all()

@router.post("/", response_model=IngredientRead)
async def create_ingredient(
    ing_in: IngredientCreate, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    new_ing = Ingredient(**ing_in.model_dump())
    db.add(new_ing)
    await db.commit()
    await db.refresh(new_ing)
    return new_ing


@router.post("/link-to-menu", status_code=status.HTTP_201_CREATED)
async def link_ingredient_to_item(
    link_in: RecipeLinkCreate, 
    db: AsyncSession = Depends(get_db),
    current_user = Depends(is_staff)
):
    item = await db.get(MenuItem, link_in.menu_item_id)
    ing = await db.get(Ingredient, link_in.ingredient_id)
    
    if not item or not ing:
        raise HTTPException(status_code=404, detail="MenuItem or Ingredient not found")

    new_link = MenuItemIngredient(**link_in.model_dump())
    await db.merge(new_link)
    await db.commit()
    return {"message": f"Ingredient {ing.name} linked to {item.name}"}

@router.get("/recipe/{menu_item_id}", response_model=List[RecipeRead])
async def get_recipe(menu_item_id: int, db: AsyncSession = Depends(get_db)):
    """ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ ÑĞ¾ÑÑ‚Ğ°Ğ² ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ»ÑĞ´Ğ°"""
    result = await db.execute(
        select(MenuItemIngredient)
        .options(selectinload(MenuItemIngredient.ingredient))
        .where(MenuItemIngredient.menu_item_id == menu_item_id)
    )
    links = result.scalars().all()
    
    return [
        {
            "ingredient_id": l.ingredient_id,
            "ingredient_name": l.ingredient.name,
            "amount": l.amount,
            "unit": l.ingredient.unit
        } for l in links
    ]


################################################################################
FILE: models/menu.py
################################################################################

from typing import List, Optional
from sqlalchemy import String, Integer, Float, ForeignKey, Boolean, Text
from sqlalchemy.orm import Mapped, mapped_column, relationship
from core.database import Base

class Category(Base):
    __tablename__ = "categories"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
    
    items: Mapped[List["MenuItem"]] = relationship("MenuItem", back_populates="category", cascade="all, delete-orphan")

    def __repr__(self) -> str:
        return f"<Category(name={self.name})>"

class MenuItem(Base):
    __tablename__ = "menu_items"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text)
    price: Mapped[float] = mapped_column(Float, nullable=False)
    is_available: Mapped[bool] = mapped_column(Boolean, default=True)
    
    category_id: Mapped[int] = mapped_column(ForeignKey("categories.id", ondelete="CASCADE"), nullable=False)
    
    category: Mapped["Category"] = relationship("Category", back_populates="items")

    def __repr__(self) -> str:
        return f"<MenuItem(name={self.name}, price={self.price})>"
    
    ingredient_links: Mapped[list["MenuItemIngredient"]] = relationship(
        "MenuItemIngredient", back_populates="menu_item", cascade="all, delete-orphan"
    )


################################################################################
FILE: models/__init__.py
################################################################################

from core.database import Base
from models.user import User, Role
from models.restaurant import Restaurant, Table
from models.menu import Category, MenuItem
from models.ingredient import Ingredient, MenuItemIngredient
from models.order import Order, OrderItem


################################################################################
FILE: models/user.py
################################################################################

from datetime import datetime
from typing import List, Optional
from sqlalchemy import String, Integer, ForeignKey, Boolean, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship

from core.database import Base

class Role(Base):
    __tablename__ = "roles"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(String(200))

    users: Mapped[List["User"]] = relationship("User", back_populates="role")

    def __repr__(self) -> str:
        return f"<Role(name={self.name})>"

class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True, nullable=False)
    email: Mapped[str] = mapped_column(String(100), unique=True, index=True, nullable=False)
    hashed_password: Mapped[str] = mapped_column(String(255), nullable=False)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())
    
    role_id: Mapped[int] = mapped_column(ForeignKey("roles.id"), nullable=False)
    
    role: Mapped["Role"] = relationship("Role", back_populates="users")

    def __repr__(self) -> str:
        return f"<User(username={self.username}, role={self.role_id})>"


################################################################################
FILE: models/order.py
################################################################################

from datetime import datetime
from typing import List, Optional
from sqlalchemy import String, Integer, ForeignKey, DateTime, func, Enum, Float
from sqlalchemy.orm import Mapped, mapped_column, relationship
from core.database import Base
import enum

class OrderStatus(enum.Enum):
    PENDING = "pending"
    PROCESSING = "processing"
    COMPLETED = "completed"
    CANCELLED = "cancelled"

class Order(Base):
    __tablename__ = "orders"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, server_default=func.now())
    
    status: Mapped[OrderStatus] = mapped_column(
        Enum(OrderStatus), default=OrderStatus.PENDING
    )

    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False)
    table_id: Mapped[Optional[int]] = mapped_column(ForeignKey("tables.id"), nullable=True)

    user: Mapped["User"] = relationship("User")
    table: Mapped["Table"] = relationship("Table")
    items: Mapped[List["OrderItem"]] = relationship("OrderItem", back_populates="order", cascade="all, delete-orphan")

    def __repr__(self) -> str:
        return f"<Order(id={self.id}, status={self.status})>"

class OrderItem(Base):
    """ĞšĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğµ Ğ±Ğ»ÑĞ´Ğ° Ğ²Ğ½ÑƒÑ‚Ñ€Ğ¸ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ°"""
    __tablename__ = "order_items"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    order_id: Mapped[int] = mapped_column(ForeignKey("orders.id", ondelete="CASCADE"), nullable=False)
    menu_item_id: Mapped[int] = mapped_column(ForeignKey("menu_items.id"), nullable=False)
    
    quantity: Mapped[int] = mapped_column(Integer, default=1)
    price_at_order: Mapped[float] = mapped_column(Float, nullable=False)

    order: Mapped["Order"] = relationship("Order", back_populates="items")
    menu_item: Mapped["MenuItem"] = relationship("MenuItem")

    def __repr__(self) -> str:
        return f"<OrderItem(order_id={self.order_id}, menu_item_id={self.menu_item_id})>"


################################################################################
FILE: models/restaurant.py
################################################################################

from typing import List
from sqlalchemy import String, Integer, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship
from core.database import Base

class Restaurant(Base):
    __tablename__ = "restaurants"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    address: Mapped[str] = mapped_column(String(255), nullable=False)
    phone: Mapped[str] = mapped_column(String(20), nullable=True)

    # Ğ¡Ğ²ÑĞ·ÑŒ: ĞĞ´Ğ¸Ğ½ Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½ -> ĞœĞ½Ğ¾Ğ³Ğ¾ ÑÑ‚Ğ¾Ğ»Ğ¾Ğ²
    tables: Mapped[List["Table"]] = relationship("Table", back_populates="restaurant", cascade="all, delete-orphan")

    def __repr__(self) -> str:
        return f"<Restaurant(name={self.name})>"

class Table(Base):
    __tablename__ = "tables"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    number: Mapped[int] = mapped_column(Integer, nullable=False) # ĞĞ¾Ğ¼ĞµÑ€ ÑÑ‚Ğ¾Ğ»Ğ° Ğ² Ğ·Ğ°Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğ¸
    capacity: Mapped[int] = mapped_column(Integer, default=2)    # Ğ’Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ (Ñ‡ĞµĞ»)
    
    # Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğ¹ ĞºĞ»ÑÑ‡ Ğ½Ğ° Ñ€ĞµÑÑ‚Ğ¾Ñ€Ğ°Ğ½
    restaurant_id: Mapped[int] = mapped_column(ForeignKey("restaurants.id", ondelete="CASCADE"), nullable=False)
    
    # ĞĞ±Ñ€Ğ°Ñ‚Ğ½Ğ°Ñ ÑĞ²ÑĞ·ÑŒ
    restaurant: Mapped["Restaurant"] = relationship("Restaurant", back_populates="tables")

    def __repr__(self) -> str:
        return f"<Table(number={self.number}, restaurant_id={self.restaurant_id})>"


################################################################################
FILE: models/ingredient.py
################################################################################

from sqlalchemy import String, Integer, Float, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship
from core.database import Base

class MenuItemIngredient(Base):
    """ĞŸÑ€Ğ¾Ğ¼ĞµĞ¶ÑƒÑ‚Ğ¾Ñ‡Ğ½Ğ°Ñ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ´Ğ»Ñ Ñ€ĞµÑ†ĞµĞ¿Ñ‚Ğ¾Ğ² (Many-to-Many Ñ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¼Ğ¸)"""
    __tablename__ = "menu_item_ingredients"

    menu_item_id: Mapped[int] = mapped_column(
        ForeignKey("menu_items.id", ondelete="CASCADE"), primary_key=True
    )
    ingredient_id: Mapped[int] = mapped_column(
        ForeignKey("ingredients.id", ondelete="CASCADE"), primary_key=True
    )
    # Ğ¡ĞºĞ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ¸Ğ½Ğ³Ñ€ĞµĞ´Ğ¸ĞµĞ½Ñ‚Ğ° Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ´Ğ»Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ»ÑĞ´Ğ° (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, 0.5 ĞºĞ³)
    amount: Mapped[float] = mapped_column(Float, nullable=False)

    # Ğ¡Ğ²ÑĞ·Ğ¸ Ğ´Ğ»Ñ ÑƒĞ´Ğ¾Ğ±Ğ½Ğ¾Ğ³Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    menu_item: Mapped["MenuItem"] = relationship(back_populates="ingredient_links")
    ingredient: Mapped["Ingredient"] = relationship(back_populates="menu_item_links")

class Ingredient(Base):
    __tablename__ = "ingredients"

    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String(100), unique=True, nullable=False)
    unit: Mapped[str] = mapped_column(String(20), nullable=False) # Ğ³, Ğ¼Ğ», ÑˆÑ‚
    stock_quantity: Mapped[float] = mapped_column(Float, default=0.0) # ĞÑÑ‚Ğ°Ñ‚Ğ¾Ğº Ğ½Ğ° ÑĞºĞ»Ğ°Ğ´Ğµ

    # Ğ¡Ğ²ÑĞ·ÑŒ Ñ Ñ€ĞµÑ†ĞµĞ¿Ñ‚Ğ°Ğ¼Ğ¸
    menu_item_links: Mapped[list["MenuItemIngredient"]] = relationship(
        back_populates="ingredient"
    )

    def __repr__(self) -> str:
        return f"<Ingredient(name={self.name}, stock={self.stock_quantity})>"


################################################################################
FILE: services/export_service.py
################################################################################

import csv
import json
from io import StringIO
from typing import List, Any

def to_json(data: List[Any]) -> str:
    return json.dumps(data, indent=4, ensure_ascii=False)

def to_csv(data: List[dict]) -> str:
    if not data:
        return ""
    
    output = StringIO()
    writer = csv.DictWriter(output, fieldnames=data[0].keys())
    writer.writeheader()
    writer.writerows(data)
    return output.getvalue()


################################################################################
FILE: services/backup_service.py
################################################################################

import os
import subprocess
from datetime import datetime
from core.config import settings

def create_db_backup():
    backup_dir = "backups"
    if not os.path.exists(backup_dir):
        os.makedirs(backup_dir)

    db_url = settings.DATABASE_URL.replace("+asyncpg", "")
    
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_path = os.path.join(backup_dir, f"backup_{timestamp}.sql")
    try:
        command = f"pg_dump {db_url} > {backup_path}"
        
        subprocess.run(command, shell=True, check=True)
        
        return {
            "status": "success",
            "filename": f"backup_{timestamp}.sql",
            "path": abspath(backup_path),
            "size_kb": os.path.getsize(backup_path) // 1024
        }
    except Exception as e:
        return {"status": "error", "message": str(e)}

def abspath(path):
    return os.path.abspath(path)

